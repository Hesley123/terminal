package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"
)

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func run() error {
	data, err := fetch(`https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt`)
	if err != nil {
		return err
	}

	testString := strings.Builder{}

	scanner := bufio.NewScanner(bytes.NewReader(data))
	firstLine := true

	for scanner.Scan() {
		line := scanner.Text()
		test, comment, _ := strings.Cut(line, "#")
		test = strings.TrimSpace(test)
		comment = strings.TrimSpace(comment)

		if firstLine {
			firstLine = false

			re, err := regexp.Compile(`^GraphemeBreakTest-(\d+\.\d+\.\d+)\.txt$`)
			if err != nil {
				return err
			}

			m := re.FindStringSubmatch(comment)
			if len(m) == 0 {
				return fmt.Errorf("failed to find version number, got: %s", comment)
			}

			_, _ = fmt.Fprintf(
				&testString,
				`// Generated by CodepointWidthDetector_gen.go
// on %s, from Unicode %s
struct GraphemeBreakTest
{
    const wchar_t* comment;
    const wchar_t* graphemes[4];
};
static constexpr GraphemeBreakTest s_graphemeBreakTests[] = {
`,
				time.Now().UTC().Format(time.RFC3339),
				m[1],
			)
		}
		// # GraphemeBreakTest-15.1.0.txt

		if len(test) == 0 || len(comment) == 0 {
			continue
		}

		graphemes := strings.Split(test, "รท")
		for i, g := range graphemes {
			graphemes[i] = strings.TrimSpace(g)
		}

		testString.WriteString("")
		_, _ = fmt.Fprintf(&testString, `    { L"%s"`, comment)

		for _, g := range graphemes {
			if len(g) == 0 {
				continue
			}

			testString.WriteString(`, L"`)

			codepoints := strings.Split(g, "ร")
			for _, c := range codepoints {
				i, err := strconv.ParseUint(strings.TrimSpace(c), 16, 32)
				if err != nil {
					return err
				}
				if i == 0x07 {
					testString.WriteString(`\a`)
				} else if i == 0x08 {
					testString.WriteString(`\b`)
				} else if i == 0x09 {
					testString.WriteString(`\t`)
				} else if i == 0x0A {
					testString.WriteString(`\n`)
				} else if i == 0x0B {
					testString.WriteString(`\v`)
				} else if i == 0x0C {
					testString.WriteString(`\f`)
				} else if i == 0x0D {
					testString.WriteString(`\r`)
				} else if i >= 0x20 && i <= 0x7e {
					testString.WriteRune(rune(i))
				} else if i <= 0xff {
					_, _ = fmt.Fprintf(&testString, `\x%02X`, i)
				} else if i <= 0xffff {
					_, _ = fmt.Fprintf(&testString, `\x%04X`, i)
				} else {
					_, _ = fmt.Fprintf(&testString, `\U%08X`, i)
				}
			}

			testString.WriteString(`"`)
		}

		testString.WriteString(" },\n")
	}

	testString.WriteString("};\n")
	_, _ = os.Stdout.WriteString(testString.String())
	return nil
}

func fetch(url string) ([]byte, error) {
	res, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	return body, nil
}
